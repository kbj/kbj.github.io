[["React学习笔记（一）- 面向组件编程","2021年08月08日","/2021/08/18/react-1.html/","\r1、基本理解和使用\r函数式组件\r类式组件\r2、State\rstate是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合) 组件被称为\u0026quot;状态机\u0026quot;, 通过更新组件的state来更新对应的页面显示(重新渲染组件) 组件中render方法中的this为组件实例对象 组件自定义的方法中this为undefined，如何解决？ 强制绑定this: 通过函数对象的bind() 箭头函数 状态数据，不能直接修改或更新 ，用setState更新，是合并的动作 setState引起组件的后续动作是异步的！！！！！！ 精简代码写法 2.1、setState\rsetState更新状态的2种写法 对象式的setState\rstateChange为状态改变对象(该对象可以体现出状态的更改) callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用 函数式的setState\rupdater为返回stateChange对象的函数 updater可以接收到state和props callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用 总结\r对象式的setState是函数式的setState的简写方式(语法糖) 使用原则： 如果新状态不依赖于原状态 ===\u0026gt; 使用对象方式 如果新状态依赖于原状态 ===\u0026gt; 使用函数方式 如果需要在setState()执行后获取最新的状态数据，要在第二个callback函数中读取 3、props\rprops是只读的 标签体的内容也是可以通过props中的children属性拿到，是一种特殊的标签属性 3.1、基本使用\r3.2、批量传递props\r3.3、对props传值做类型限制\r需要引入prop-types.js props简写： 3.4、函数式组件使用props\r4、refs\r组件内的标签可以定义ref属性来标识自己 4.1、字符串形式的ref（过时）\r4.2、回调形式的ref\r如果ref回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数null，然后第二次会传入参数DOM元素。这是因为在每次渲染时会创建一个新的函数实例，所以React 清空旧的ref并且设置新的。通过将ref的回调函数定义成class的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。 4.3、createRef使用\r5、事件处理\r通过onXxx属性指定事件处理函数(注意大小写) React使用的是自定义(合成)事件, 而不是使用的原生DOM事件 React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) 通过event.target得到发生事件的DOM元素对象 6、高阶函数与函数柯里化\r高阶函数：如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数 若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数 若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数 函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式 用函数柯里化实现： 不用函数柯里化实现： 7、组件的生命周期\r7.1、生命周期流程图(旧)\r生命周期流程图(旧) 初始化阶段: 由ReactDOM.render()触发\u0026mdash;初次渲染 constructor() componentWillMount() render() componentDidMount() 更新阶段: 由组件内部this.setSate()或父组件重新render触发 shouldComponentUpdate() componentWillUpdate() render() componentDidUpdate() 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 componentWillUnmount() 7.2、生命周期流程图(新，17以后)\r生命周期流程图 初始化阶段: 由ReactDOM.render()触发\u0026mdash;初次渲染 constructor() getDerivedStateFromProps(props,state)：从props中得到派生的状态，也就是state的值在任何时候都取决于props时使用 render() componentDidMount() 更新阶段: 由组件内部this.setSate()或父组件重新render触发 getDerivedStateFromProps(props,state)：从props中得到派生的状态，也就是state的值在任何时候都取决于props时使用 shouldComponentUpdate() render() getSnapshotBeforeUpdate componentDidUpdate(preProps, preState)：preProps和preState都是更新前的数据 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 componentWillUnmount() 若state的值在任何时候都取决于props，那么可以使用getDerivedStateFromProps 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate() 7.3、重要的勾子\rrender：初始化渲染或更新渲染调用 componentDidMount：开启监听, 发送ajax请求 componentWillUnmount：做一些收尾工作, 如: 清理定时器 7.4、即将废弃的勾子\rcomponentWillMount componentWillReceiveProps componentWillUpdate 8、虚拟DOM与DOM Diffing算法\r虚拟DOM与DOM Diffing算法 "],["Raspberry Pi编译安装OpenCV4","2019年09月09日","/2019/09/09/raspberry-pi-compile-install-opencv4.html/","\r前言\r因为最近准备往树莓派上放一个基于OpenCV的项目，在PC上测试没有问题后放在树莓派上 的时候却提示： 再去网上搜索后才发现 这个库并没有提供ARM架构的二进制包。不过偶然发现还有一个专门为树莓派提供的第三方依赖库\r，可是这里目前只提供基于Python3.5且版本号太低无法满足我当前项目的要求，那接下来就只剩下源码自己独立编译这条路了。 环境准备\rPython3.7.4 需要安装Numpy： 扩展文件系统 输入 选择 选择 扩充Swap 编辑文件： ，将 的值修改成 重启dphys-swapfile： 更新系统的包 在系统中安装相关依赖 下载源码并解压 编译安装\r在 中创建 文件夹，用于存放源码编译后的产物 配置CMake参数 在CMake检查结束后，会打印出详细的信息，需要检查其中 部分的各个参数是否都有值。 确认没问题后即开始编译OpenCV，建议可以在这时候使用 命令创建一个可以在后台持续执行的会话。 可以在make后增加 参数指定使用2个核心参与编译，这里使用单核编译，即不加任何参数。敲完命令后就需要等待大约七八小时后才能完成（Raspberry Pi 3B） 编译结束并且没有报错信息后，需要修改一下配置， 中第一行增加 参数 在第一行中的起始中 修改为 安装OpenCV 检查安装结果\r参考链接\r【树莓派】编译安装opencv+python调用\rInstall OpenCV 4 on your Raspberry Pi\r"],["存储过程","2018年09月09日","/2018/09/04/learn-procedure.html/","公司的项目使用到了存储过程，由于此前在学校从未接触到，因此记录下学习笔记。 什么是存储过程\r存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。 使用存储过程的优点\r存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。 当对数据库进行复杂操作时，可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。 存储过程可以重复使用,可减少数据库开发人员的工作量。 安全性高,可设定只有某些用户才具有对指定存储过程的使用权。 简单例子\r基本语法\r存储过程或者存储函数，只能创建或者替换。 参数可以带也可以不带。 不带参数的存储过程\r带参数的存储过程\r给指定的员工涨100元工资,并且打印涨前和涨后的薪水: 注意 要明确说明参数是输入参数（in)还是输出参数（out) 为保证调用多个存储过程中处在同一个事务中，所以一般不在存储过程或者存储函数中，commit或rollback 调用执行方式\r命令 exec是SQLPlus命令，只能在SQLPlus中使用，exec可以直接跟存储过程名（可以省略括号） 使用 命令 在SQL中使用 调用存储过程时，需要带上括号，不限制使用场景 使用PLSQL语句调用 "]]